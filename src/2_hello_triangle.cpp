//
// Created by fangjun on 24/09/16.
//

//! @defgroup group_hello_triangle Hello triangle
//! @ingroup group_basics
//! This page shows how to draw a triangle in OpenGL.
//! <h3>Introduction</h3>
//!
//! From OpenGL 3.3, there is no default vertex shader and
//! fragment shader. Thus, the user has to provide his own
//! shaders in order to display any data.
//!
//! To draw a triangle, we have to specify the coordinates of its three corners.
//! The coordinate in OpenGL is 3-d, which has a range [-1, 1]. This is also known
//! as normalized device coordinates.
//! As the three corners of our triangle lie on the same plane, we set its z component
//! to 0.
//!
//! Coordinates of the three corners:
//!  - Top: 0, 0.5, 0
//!  - Bottom left: -0.5, -0.5, 0
//!  - Bottom right: 0.5, -0.5, 0
//!
//! To pass the coordinates data to the GPU, we can use vertex buffer objects.
//! Every object is identified by its ID, which is generated by the function
//! [glGenBuffers](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenBuffers.xhtml).
//! See also
//!  - [glDeleteBuffers](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteBuffers.xhtml)
//!  - [glBindBuffer](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffer.xhtml)
//!  - [glBufferData](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferData.xhtml)
//!
//! See the [Manual](https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glBegin.xml)
//! for explanations to `GL_POINTS`, `GL_LINES`, `GL_LINE_STRIP`, etc.
//!
//! <h3>References</h3>
//!  - [What is the role of glBindVertexArrays vs glBindBuffer and what is their relationship?](http://stackoverflow.com/questions/21652546/what-is-the-role-of-glbindvertexarrays-vs-glbindbuffer-and-what-is-their-relatio)
//! at stackoverflow, it gives a detailed explanation to vertex array object, vertex buffer array object.


#include "common.hpp"
#include "shader.hpp"


//! This functions shows how to draw a triangle in OpenGL.
//! In general, it follows the following **fixed steps** to draw something in OpenGL:
//! -# create a window (i.e., a context)
//! -# create a vertex shader and a fragment shader and link them to a program
//! -# specify the coordinates of the shape
//! -# create a buffer object to store the coordinates, color and other info about the shape
//! -# create a vertex array object and set its vertex attribute pointer
//! -# make the vertex array object active and use `glDrawArrays` to draw the shape by
//! specifying its starting vertex and the number of vertices to draw.
//! @sa hello_triangle_with_element_buffer
int hello_triangle()
{
    std::string vertex_shader_filename = g_shader_path + "/src/shaders/2_hello_triangle_vertex_shader.txt";
    std::string fragment_shader_filename = g_shader_path + "/src/shaders/2_hello_triangle_fragment_shader.txt";

    GLFWwindow *window;
    create_context(&window);

    Shader shader;
    shader.setVertexShaderFilename(vertex_shader_filename);
    shader.setFragShaderFilename(fragment_shader_filename);
    shader.linkProgram();

    // set the coordinates of the triangle vertices
    GLfloat vertices[] = {
            -0.5f, -0.5f, 0.0f, // 0, left vertex
            0.5f, -0.5f, 0.0f,  // 1, right vertex
            0.0f, 0.5f, 0.0f,   // 2, top vertex
    };

    // vertex array object
    GLuint vao;
    glGenVertexArrays(1, &vao);
    glBindVertexArray(vao);

    // vertex buffer object
    GLuint vbo;
    glGenBuffers(1, &vbo);
    glBindBuffer(GL_ARRAY_BUFFER ,vbo);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

    glVertexAttribPointer(
            0, // index, which attribute
            3, // number of component per vertex attribute. Each coordinate contains 3 component
            GL_FLOAT, // data type of each component
            GL_FALSE, // need to be normalized ?
            0,  // stride, 0 -> compact, OpenGL will compute it. non-zero --> number of bytes between two consecutive vertices
            nullptr);   // offset

    glEnableVertexAttribArray(0);

    glBindBuffer(GL_ARRAY_BUFFER, 0);   // reset
    glBindVertexArray(0);

    shader.useProgram();
    while(!glfwWindowShouldClose(window))
    {
        glfwPollEvents();

        // clear the color buffer, RGBA
        glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);

        // draw the triangle
        glBindVertexArray(vao);
        glDrawArrays(
                GL_TRIANGLES, // primitives
                0, // starting index
                3 // number of indices
        );
        glBindVertexArray(0); // reset;

        glfwSwapBuffers(window);
    }

    glDeleteBuffers(1, &vbo);
    glDeleteVertexArrays(1, &vao);

    glfwTerminate();

    return 0;
}
